import { NextRequest, NextResponse } from "next/server";
import { Vertical } from "@/lib/types";

// We cannot use pdfkit directly in the Next.js edge runtime.
// This route runs in Node.js runtime with full buffer support.
export const runtime = "nodejs";
export const dynamic = "force-dynamic";

export async function GET(req: NextRequest) {
    const { searchParams } = new URL(req.url);
    const brand = searchParams.get("brand");
    const vertical = searchParams.get("vertical") as Vertical | null;

    if (!brand || !vertical) {
        return NextResponse.json({ error: "brand and vertical params required" }, { status: 400 });
    }

    try {
        // 1. Fetch full audit report from the JSON route
        const host = req.headers.get("host") || "localhost:3000";
        const protocol = host.includes("localhost") ? "http" : "https";
        const auditRes = await fetch(
            `${protocol}://${host}/api/audit?brand=${encodeURIComponent(brand)}&vertical=${encodeURIComponent(vertical)}`
        );

        if (!auditRes.ok) {
            const err = await auditRes.json();
            return NextResponse.json({ error: err.error || "Audit fetch failed" }, { status: 500 });
        }

        const audit = await auditRes.json();

        // 2. Build PDF using pdfkit
        const PDFDocument = (await import("pdfkit")).default;
        const chunks: Buffer[] = [];

        const doc = new PDFDocument({ margin: 50, size: "A4" });

        doc.on("data", (chunk: Buffer) => chunks.push(chunk));

        // ── Cover Page ──────────────────────────────
        doc
            .fontSize(28)
            .fillColor("#1a1a2e")
            .text("AI Visibility Audit Report", { align: "center" })
            .moveDown(0.5);

        doc
            .fontSize(16)
            .fillColor("#4a4e69")
            .text(`${brand} · ${vertical}`, { align: "center" })
            .moveDown(0.3);

        doc
            .fontSize(10)
            .fillColor("#888")
            .text(`Generated by Ghost Recon · ${new Date(audit.generatedAt).toLocaleDateString("en-US", { year: "numeric", month: "long", day: "numeric" })}`, { align: "center" })
            .moveDown(1.5);

        // ── Executive Summary ────────────────────────
        sectionHeader(doc, "Executive Summary");
        doc.fontSize(11).fillColor("#333").text(audit.executiveSummary, { align: "justify" }).moveDown(1);

        // ── AVS Scores ───────────────────────────────
        sectionHeader(doc, "AI Visibility Score (AVS)");
        scoreRow(doc, "AVS (Flat)", audit.avs);
        scoreRow(doc, "Weighted AVS", audit.weightedAvs);
        scoreRow(doc, "AVS Trend Delta", audit.avsDelta, true);
        scoreRow(doc, "Tracked Share of Voice", audit.tsov, false, "%");
        doc.moveDown(0.5);

        // ── LLM Breakdown ────────────────────────────
        sectionHeader(doc, "LLM-Specific AVS Breakdown");
        scoreRow(doc, "ChatGPT", audit.avsBreakdown.chatgpt);
        scoreRow(doc, "Gemini", audit.avsBreakdown.gemini);
        scoreRow(doc, "Perplexity", audit.avsBreakdown.perplexity);
        doc.moveDown(0.5);
        doc
            .fontSize(9)
            .fillColor("#888")
            .text("Note: Tracked SOV sums to 100 within the monitored brand set — not total market share.")
            .moveDown(1);

        // ── Narrative Intelligence ───────────────────
        sectionHeader(doc, "AI Narrative Intelligence");
        label(doc, "Narrative Summary");
        doc.fontSize(11).fillColor("#333").text(audit.narrative.narrativeSummary, { align: "justify" }).moveDown(0.5);
        label(doc, "Positioning Category");
        doc.fontSize(11).fillColor("#333").text(audit.narrative.positioningCategory).moveDown(0.5);
        label(doc, "Authority Strength Score");
        doc.fontSize(11).fillColor("#333").text(`${audit.authorityStrengthScore} / 100`).moveDown(0.5);
        label(doc, "Signature Adjectives");
        doc.fontSize(11).fillColor("#333").text(audit.narrative.signatureAdjectives.join("  ·  ")).moveDown(0.5);
        label(doc, "Differentiation Signals");
        audit.narrative.differentiationSignals.forEach((sig: string) => {
            doc.fontSize(11).fillColor("#333").text(`• ${sig}`);
        });
        doc.moveDown(1);

        // ── Narrative Drift ──────────────────────────
        if (audit.narrative.narrativeShift) {
            sectionHeader(doc, "Narrative Drift");
            label(doc, "What Changed");
            doc.fontSize(11).fillColor("#333").text(audit.narrative.narrativeShift).moveDown(0.3);
            if (audit.narrative.emergingThemes?.length) {
                label(doc, "Emerging Themes");
                doc.fontSize(11).fillColor("#2a9d8f").text(audit.narrative.emergingThemes.join("  ·  ")).moveDown(0.3);
            }
            if (audit.narrative.lostThemes?.length) {
                label(doc, "Lost Themes");
                doc.fontSize(11).fillColor("#e63946").text(audit.narrative.lostThemes.join("  ·  ")).moveDown(0.3);
            }
            doc.moveDown(0.5);
        }

        // ── Competitor Gap ───────────────────────────
        if (audit.topCompetitorGap) {
            const gap = audit.topCompetitorGap;
            sectionHeader(doc, `Competitor Gap: ${brand} vs ${gap.brandB}`);
            scoreRow(doc, "AVS Difference", gap.avsDifference, true);
            scoreRow(doc, "SOV Difference", gap.sovDifference, true, "%");
            scoreRow(doc, "Sentiment Gap", gap.sentimentGap, true, "%");
            if (gap.llmsCompetitorLeads.length > 0) {
                label(doc, "LLMs Where Competitor Leads");
                doc.fontSize(11).fillColor("#e63946").text(gap.llmsCompetitorLeads.join(", ")).moveDown(0.3);
            }
            label(doc, "Analysis");
            doc.fontSize(11).fillColor("#333").text(gap.summary, { align: "justify" }).moveDown(1);
        }

        // ── Strategic Recommendations ────────────────
        sectionHeader(doc, "Strategic Recommendations (Gemini-Generated)");
        audit.recommendations.forEach((rec: string, i: number) => {
            doc
                .fontSize(11)
                .fillColor("#4a4e69")
                .text(`${i + 1}.`, { continued: true })
                .fillColor("#333")
                .text(`  ${rec}`)
                .moveDown(0.4);
        });

        // ── Footer ───────────────────────────────────
        doc.moveDown(2);
        doc
            .fontSize(9)
            .fillColor("#aaa")
            .text("Ghost Recon — AI Recommendation Intelligence Platform", { align: "center" })
            .text("Confidential · For internal use only", { align: "center" });

        doc.end();

        await new Promise<void>((resolve) => doc.on("end", resolve));

        const pdfBuffer = Buffer.concat(chunks);

        return new NextResponse(pdfBuffer, {
            status: 200,
            headers: {
                "Content-Type": "application/pdf",
                "Content-Disposition": `attachment; filename="ghost-recon-audit-${brand.toLowerCase().replace(/\s+/g, "-")}.pdf"`,
                "Content-Length": pdfBuffer.length.toString(),
            },
        });
    } catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        const stack = error instanceof Error ? error.stack : "";
        console.error("[/api/audit/pdf] Error:", msg, stack);
        return NextResponse.json({ error: "PDF generation failed", detail: msg }, { status: 500 });
    }
}

// ── PDF Helpers ──────────────────────────────────────────

function sectionHeader(doc: InstanceType<typeof import("pdfkit")>, title: string) {
    doc
        .moveDown(0.5)
        .fontSize(14)
        .fillColor("#1a1a2e")
        .text(title)
        .moveTo(doc.x, doc.y)
        .lineTo(doc.page.width - 50, doc.y)
        .stroke("#e0e0e0")
        .moveDown(0.5);
}

function label(doc: InstanceType<typeof import("pdfkit")>, text: string) {
    doc.fontSize(9).fillColor("#888").text(text.toUpperCase()).moveDown(0.1);
}

function scoreRow(
    doc: InstanceType<typeof import("pdfkit")>,
    label: string,
    value: number,
    isDelta = false,
    suffix = ""
) {
    const color = isDelta ? (value >= 0 ? "#2a9d8f" : "#e63946") : "#1a1a2e";
    const prefix = isDelta && value > 0 ? "+" : "";
    doc
        .fontSize(11)
        .fillColor("#555")
        .text(`${label}: `, { continued: true })
        .fillColor(color)
        .text(`${prefix}${Math.round(value * 10) / 10}${suffix}`)
        .moveDown(0.3);
}
